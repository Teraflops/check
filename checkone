import scala.io.Source
import scala.util.{Try, Success, Failure}
import scala.collection.mutable
import java.io.PrintWriter

object EnhancedConfigParser {
  
  // Define the keys to search for
  val jsonKeys = Array(
    "Target_config.uuid",
    "consumer_offset_start",
    "Transformation.id",
    "Checkpoint_base_path",
    "source_config.uuid",
    "print.level",
    "Consumer_group",
    "DQ",
    "Pipeline",
    "UpdUsr",
    "CrtDt",
    "groups.uuid",
    "validation.updflag",
    "LstUpdDt",
    "validation.updflag.mergeorderpartition",
    "CrtUsr"
  )
  
  case class PipelineConfig(
    name: String,
    configMap: Map[String, String],
    matchedKeys: Map[String, String]
  )
  
  def parseConfigFile(filePath: String): Map[String, String] = {
    val configMap = mutable.Map[String, String]()
    
    Try {
      val source = Source.fromFile(filePath)
      try {
        source.getLines().foreach { line =>
          val trimmedLine = line.trim
          if (trimmedLine.nonEmpty && !trimmedLine.startsWith("#")) {
            val parts = trimmedLine.split("=", 2)
            if (parts.length == 2) {
              val key = parts(0).trim
              val value = parts(1).trim
              configMap(key) = value
            }
          }
        }
      } finally {
        source.close()
      }
    } match {
      case Success(_) => println(s"Successfully parsed config file: $filePath")
      case Failure(exception) => 
        println(s"Error reading file: ${exception.getMessage}")
        return Map.empty
    }
    
    configMap.toMap
  }
  
  def extractPipelines(configMap: Map[String, String]): List[String] = {
    // Look for the "pipelines" key and extract comma-separated values
    configMap.get("pipelines") match {
      case Some(pipelinesStr) =>
        val pipelines = pipelinesStr.split(",").map(_.trim).filter(_.nonEmpty).toList
        println(s"Found pipelines: ${pipelines.mkString(", ")}")
        pipelines
      case None =>
        // If no "pipelines" key found, extract unique pipeline names from config keys
        val pipelineNames = configMap.keys
          .filter(_.contains("."))
          .map(_.split("\\.")(0))
          .toSet
          .toList
        println(s"Extracted pipeline names from config keys: ${pipelineNames.mkString(", ")}")
        pipelineNames
    }
  }
  
  def filterConfigForPipeline(configMap: Map[String, String], pipelineName: String): Map[String, String] = {
    // Filter config entries that start with the pipeline name
    val pipelineConfig = configMap.filter { case (key, _) =>
      key.startsWith(s"$pipelineName.")
    }
    
    // Also include global config entries (those without dots or common global keys)
    val globalConfig = configMap.filter { case (key, _) =>
      !key.contains(".") || isGlobalConfigKey(key)
    }
    
    val combinedConfig = pipelineConfig ++ globalConfig
    println(s"Pipeline '$pipelineName': Found ${combinedConfig.size} relevant config entries")
    combinedConfig
  }
  
  def isGlobalConfigKey(key: String): Boolean = {
    // Define patterns for global configuration keys
    val globalPatterns = Array(
      "pipelines",
      "global.",
      "common.",
      "default."
    )
    globalPatterns.exists(pattern => key.toLowerCase.startsWith(pattern.toLowerCase))
  }
  
  def findMatchingKeys(configMap: Map[String, String], targetKeys: Array[String], pipelineName: String): Map[String, String] = {
    val result = mutable.Map[String, String]()
    
    targetKeys.foreach { targetKey =>
      // First try exact match
      configMap.get(targetKey) match {
        case Some(value) => 
          result(targetKey) = value
          println(s"[$pipelineName] Exact match found: $targetKey = $value")
        case None =>
          // Try pipeline-specific match (pipeline.targetKey)
          val pipelineSpecificKey = s"$pipelineName.$targetKey"
          configMap.get(pipelineSpecificKey) match {
            case Some(value) =>
              result(targetKey) = value
              println(s"[$pipelineName] Pipeline-specific match found: $targetKey -> $pipelineSpecificKey = $value")
            case None =>
              // Try partial matching within pipeline scope
              val partialMatch = findPartialMatch(targetKey, configMap, pipelineName)
              partialMatch match {
                case Some((matchedKey, value)) =>
                  result(targetKey) = value
                  println(s"[$pipelineName] Partial match found: $targetKey -> $matchedKey = $value")
                case None =>
                  // Try semantic matching
                  val semanticMatch = findSemanticMatch(targetKey, configMap, pipelineName)
                  semanticMatch match {
                    case Some((matchedKey, value)) =>
                      result(targetKey) = value
                      println(s"[$pipelineName] Semantic match found: $targetKey -> $matchedKey = $value")
                    case None =>
                      result(targetKey) = "NOT_FOUND"
                      println(s"[$pipelineName] No match found for: $targetKey")
                  }
              }
          }
      }
    }
    
    result.toMap
  }
  
  def findPartialMatch(targetKey: String, configMap: Map[String, String], pipelineName: String): Option[(String, String)] = {
    val lowerTargetKey = targetKey.toLowerCase
    
    // First, try to find matches within the pipeline scope
    val pipelineKeys = configMap.filter(_._1.startsWith(s"$pipelineName."))
    
    // Look for keys that contain the target key
    pipelineKeys.find { case (configKey, _) =>
      val keyWithoutPipeline = configKey.substring(pipelineName.length + 1).toLowerCase
      keyWithoutPipeline.contains(lowerTargetKey) || lowerTargetKey.contains(keyWithoutPipeline)
    } match {
      case Some((foundKey, value)) => return Some((foundKey, value))
      case None => // Continue searching
    }
    
    // Try matching by the last part of the key within pipeline scope
    val keyParts = lowerTargetKey.split("\\.")
    if (keyParts.nonEmpty) {
      val lastPart = keyParts.last
      pipelineKeys.find { case (configKey, _) =>
        val configKeyParts = configKey.toLowerCase.split("\\.")
        configKeyParts.length > 1 && (
          configKeyParts.last == lastPart || 
          configKey.toLowerCase.contains(lastPart)
        )
      } match {
        case Some((foundKey, value)) => return Some((foundKey, value))
        case None => // Continue searching
      }
    }
    
    // Fallback to global search if no pipeline-specific match found
    configMap.find { case (configKey, _) =>
      val configKeyLower = configKey.toLowerCase
      configKeyLower.contains(lowerTargetKey) || lowerTargetKey.contains(configKeyLower)
    }
  }
  
  def findSemanticMatch(targetKey: String, configMap: Map[String, String], pipelineName: String): Option[(String, String)] = {
    val lowerTargetKey = targetKey.toLowerCase
    
    // Define semantic mappings with pipeline-aware patterns
    val semanticMappings = Map(
      "consumer_offset_start" -> Array("consumer.offset.start", "offset.start", "consumer_offset"),
      "checkpoint_base_path" -> Array("checkpoint_base_path", "checkpoint.base.path", "checkpoint"),
      "print.level" -> Array("print.level", "log.level", "level"),
      "consumer_group" -> Array("consumer.group", "consumer_group", "group"),
      "pipeline" -> Array("pipelines", "pipeline", "id"),
      "transformation.id" -> Array("transformation", "parser.id", "additional.transformation", "staging.id"),
      "target_config.uuid" -> Array("target.id", "target.uuid", "uuid"),
      "source_config.uuid" -> Array("source", "source.id", "source.uuid"),
      "dq" -> Array("validation", "dq", "data.quality"),
      "validation.updflag" -> Array("validation.flag", "validation", "updflag")
    )
    
    // Check semantic mappings with pipeline prefix first
    semanticMappings.get(lowerTargetKey) match {
      case Some(possibleKeys) =>
        // Try pipeline-specific keys first
        possibleKeys.foreach { possibleKey =>
          val pipelineSpecificPattern = s"$pipelineName.$possibleKey"
          configMap.find { case (configKey, _) =>
            configKey.toLowerCase.contains(pipelineSpecificPattern.toLowerCase)
          } match {
            case Some((foundKey, value)) => return Some((foundKey, value))
            case None => // Continue searching
          }
        }
        
        // Try general patterns within pipeline scope
        possibleKeys.foreach { possibleKey =>
          configMap.find { case (configKey, _) =>
            configKey.startsWith(s"$pipelineName.") && 
            configKey.toLowerCase.contains(possibleKey.toLowerCase)
          } match {
            case Some((foundKey, value)) => return Some((foundKey, value))
            case None => // Continue searching
          }
        }
        
        // Fallback to global search
        possibleKeys.foreach { possibleKey =>
          configMap.find { case (configKey, _) =>
            configKey.toLowerCase.contains(possibleKey.toLowerCase)
          } match {
            case Some((foundKey, value)) => return Some((foundKey, value))
            case None => // Continue searching
          }
        }
      case None => // No semantic mapping defined
    }
    
    None
  }
  
  def generateJson(matchedKeys: Map[String, String], pipelineName: String): String = {
    val jsonBuilder = new StringBuilder
    jsonBuilder.append("{\n")
    jsonBuilder.append(s"""  "pipeline_name": "$pipelineName",\n""")
    
    val entries = matchedKeys.toSeq.zipWithIndex
    entries.foreach { case ((key, value), index) =>
      val escapedKey = key.replace("\"", "\\\"")
      val escapedValue = value.replace("\"", "\\\"").replace("\\", "\\\\")
      jsonBuilder.append(s"""  "$escapedKey": "$escapedValue"""")
      if (index < entries.length - 1) {
        jsonBuilder.append(",")
      }
      jsonBuilder.append("\n")
    }
    
    jsonBuilder.append("}")
    jsonBuilder.toString()
  }
  
  def processPipelines(configMap: Map[String, String]): List[PipelineConfig] = {
    val pipelines = extractPipelines(configMap)
    
    pipelines.map { pipelineName =>
      println(s"\n=== Processing Pipeline: $pipelineName ===")
      
      // Filter config for this specific pipeline
      val pipelineConfigMap = filterConfigForPipeline(configMap, pipelineName)
      
      // Find matching keys for this pipeline
      val matchedKeys = findMatchingKeys(pipelineConfigMap, jsonKeys, pipelineName)
      
      PipelineConfig(pipelineName, pipelineConfigMap, matchedKeys)
    }
  }
  
  def saveJsonFiles(pipelineConfigs: List[PipelineConfig]): Unit = {
    pipelineConfigs.foreach { pipelineConfig =>
      val jsonOutput = generateJson(pipelineConfig.matchedKeys, pipelineConfig.name)
      val fileName = s"${pipelineConfig.name.toLowerCase}_config.json"
      
      Try {
        val writer = new PrintWriter(fileName)
        try {
          writer.write(jsonOutput)
          println(s"JSON output for pipeline '${pipelineConfig.name}' saved to: $fileName")
        } finally {
          writer.close()
        }
      } match {
        case Success(_) => // Success message already printed
        case Failure(exception) => println(s"Error saving file $fileName: ${exception.getMessage}")
      }
    }
  }
  
  def generateCombinedJson(pipelineConfigs: List[PipelineConfig]): String = {
    val jsonBuilder = new StringBuilder
    jsonBuilder.append("{\n")
    jsonBuilder.append(s"""  "total_pipelines": ${pipelineConfigs.length},\n""")
    jsonBuilder.append("""  "pipelines": [""").append("\n")
    
    pipelineConfigs.zipWithIndex.foreach { case (pipelineConfig, index) =>
      val pipelineJson = generateJson(pipelineConfig.matchedKeys, pipelineConfig.name)
      jsonBuilder.append("    ").append(pipelineJson.replace("\n", "\n    "))
      if (index < pipelineConfigs.length - 1) {
        jsonBuilder.append(",")
      }
      jsonBuilder.append("\n")
    }
    
    jsonBuilder.append("  ]\n")
    jsonBuilder.append("}")
    jsonBuilder.toString()
  }
  
  def printSummary(pipelineConfigs: List[PipelineConfig]): Unit = {
    println(s"\n=== OVERALL SUMMARY ===")
    println(s"Total pipelines processed: ${pipelineConfigs.length}")
    println(s"Target keys searched per pipeline: ${jsonKeys.length}")
    
    pipelineConfigs.foreach { pipelineConfig =>
      val foundCount = pipelineConfig.matchedKeys.count(_._2 != "NOT_FOUND")
      val notFoundCount = pipelineConfig.matchedKeys.count(_._2 == "NOT_FOUND")
      
      println(s"\nPipeline: ${pipelineConfig.name}")
      println(s"  - Keys found: $foundCount/${jsonKeys.length}")
      println(s"  - Keys not found: $notFoundCount")
      println(s"  - Success rate: ${(foundCount.toDouble / jsonKeys.length * 100).round}%")
      
      if (notFoundCount > 0) {
        println(s"  - Missing keys: ${pipelineConfig.matchedKeys.filter(_._2 == "NOT_FOUND").keys.mkString(", ")}")
      }
    }
  }
  
  def main(args: Array[String]): Unit = {
    val configFilePath = if (args.nonEmpty) args(0) else "/home/ubuntu/upload/configload.txt"
    
    println("=== Enhanced Config Parser Started ===")
    println(s"Parsing config file: $configFilePath")
    println(s"Looking for ${jsonKeys.length} keys per pipeline...")
    println()
    
    // Parse the config file
    val configMap = parseConfigFile(configFilePath)
    
    if (configMap.nonEmpty) {
      println(s"Loaded ${configMap.size} configuration entries")
      
      // Process all pipelines
      val pipelineConfigs = processPipelines(configMap)
      
      if (pipelineConfigs.nonEmpty) {
        println(s"\n=== Results for ${pipelineConfigs.length} pipelines ===")
        
        // Save individual JSON files for each pipeline
        saveJsonFiles(pipelineConfigs)
        
        // Generate and save combined JSON
        val combinedJson = generateCombinedJson(pipelineConfigs)
        Try {
          val writer = new PrintWriter("all_pipelines_config.json")
          try {
            writer.write(combinedJson)
            println(s"\nCombined JSON output saved to: all_pipelines_config.json")
          } finally {
            writer.close()
          }
        } match {
          case Success(_) => // Success message already printed
          case Failure(exception) => println(s"Error saving combined file: ${exception.getMessage}")
        }
        
        // Print summary
        printSummary(pipelineConfigs)
        
      } else {
        println("No pipelines found in configuration")
      }
      
    } else {
      println("Failed to parse config file or file is empty")
    }
    
    println("\n=== Enhanced Config Parser Completed ===")
  }
}

