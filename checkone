import scala.io.Source
import scala.util.{Try, Success, Failure}
import scala.collection.mutable
import java.io.PrintWriter
import java.time.Instant
import scala.concurrent.duration._
import scala.concurrent.{Await, Future}
import scala.concurrent.ExecutionContext.Implicits.global

// Couchbase imports (these would need to be added to build dependencies)
// import com.couchbase.client.scala._
// import com.couchbase.client.scala.json._
// import com.couchbase.client.core.error.DocumentNotFoundException

object EnhancedConfigParserWithCouchbase {
  
  // Define the keys to search for
  val jsonKeys = Array(
    "Target_config.uuid",
    "consumer_offset_start",
    "Transformation.id",
    "Checkpoint_base_path",
    "source_config.uuid",
    "print.level",
    "Consumer_group",
    "DQ",
    "Pipeline",
    "UpdUsr",
    "CrtDt",
    "groups.uuid",
    "validation.updflag",
    "LstUpdDt",
    "validation.updflag.mergeorderpartition",
    "CrtUsr"
  )
  
  case class PipelineConfig(
    name: String,
    configMap: Map[String, String],
    matchedKeys: Map[String, String]
  )
  
  case class CouchbaseConfig(
    connectionString: String,
    username: String,
    password: String,
    bucketName: String = "RTCONFIG",
    scopeName: String = "CITIDIRECT",
    collectionName: String = "PIPELINES"
  )
  
  // Mock Couchbase client interface (replace with actual Couchbase SDK)
  trait CouchbaseClient {
    def insert(key: String, document: String): Try[Unit]
    def close(): Unit
  }
  
  // Mock implementation for demonstration (replace with actual Couchbase client)
  class MockCouchbaseClient(config: CouchbaseConfig) extends CouchbaseClient {
    println(s"Mock Couchbase Client initialized:")
    println(s"  Connection: ${config.connectionString}")
    println(s"  Bucket: ${config.bucketName}")
    println(s"  Scope: ${config.scopeName}")
    println(s"  Collection: ${config.collectionName}")
    
    override def insert(key: String, document: String): Try[Unit] = {
      Try {
        println(s"Mock Insert - Key: $key")
        println(s"Mock Insert - Document: ${document.take(100)}...")
        // Simulate successful insert
        Thread.sleep(100) // Simulate network latency
      }
    }
    
    override def close(): Unit = {
      println("Mock Couchbase Client closed")
    }
  }
  
  // Actual Couchbase client implementation (uncomment when Couchbase SDK is available)
  /*
  class ActualCouchbaseClient(config: CouchbaseConfig) extends CouchbaseClient {
    private val cluster = Cluster.connect(config.connectionString, config.username, config.password)
    private val bucket = cluster.bucket(config.bucketName)
    private val scope = bucket.scope(config.scopeName)
    private val collection = scope.collection(config.collectionName)
    
    override def insert(key: String, document: String): Try[Unit] = {
      Try {
        val jsonObject = JsonObject.fromJson(document)
        val result = Await.result(collection.insert(key, jsonObject), 10.seconds)
        println(s"Successfully inserted document with key: $key")
      }.recoverWith {
        case ex: Exception =>
          println(s"Failed to insert document with key $key: ${ex.getMessage}")
          Failure(ex)
      }
    }
    
    override def close(): Unit = {
      cluster.disconnect()
    }
  }
  */
  
  def getCurrentEpochMillis(): String = {
    Instant.now().toEpochMilli.toString
  }
  
  def generateDefaultValue(key: String, pipelineName: String): String = {
    key match {
      case "LstUpdDt" => getCurrentEpochMillis()
      case "CrtDt" => getCurrentEpochMillis()
      case "CrtUsr" => "Admin"
      case "UpdUsr" => "Admin"
      case "Target_config.uuid" => s"${pipelineName}+Couchbase+${pipelineName}+Iceberg"
      case _ => "NOT_FOUND"
    }
  }
  
  def shouldUseDefaultValue(key: String): Boolean = {
    // These keys should always use default values when not found exactly
    Array("Target_config.uuid", "LstUpdDt", "CrtDt", "CrtUsr", "UpdUsr").contains(key)
  }
  
  def parseConfigFile(filePath: String): Map[String, String] = {
    val configMap = mutable.Map[String, String]()
    
    Try {
      val source = Source.fromFile(filePath)
      try {
        source.getLines().foreach { line =>
          val trimmedLine = line.trim
          if (trimmedLine.nonEmpty && !trimmedLine.startsWith("#")) {
            val parts = trimmedLine.split("=", 2)
            if (parts.length == 2) {
              val key = parts(0).trim
              val value = parts(1).trim
              configMap(key) = value
            }
          }
        }
      } finally {
        source.close()
      }
    } match {
      case Success(_) => println(s"Successfully parsed config file: $filePath")
      case Failure(exception) => 
        println(s"Error reading file: ${exception.getMessage}")
        return Map.empty
    }
    
    configMap.toMap
  }
  
  def extractPipelines(configMap: Map[String, String]): List[String] = {
    // Look for the "pipelines" key and extract comma-separated values
    configMap.get("pipelines") match {
      case Some(pipelinesStr) =>
        val pipelines = pipelinesStr.split(",").map(_.trim).filter(_.nonEmpty).toList
        println(s"Found pipelines: ${pipelines.mkString(", ")}")
        pipelines
      case None =>
        // If no "pipelines" key found, extract unique pipeline names from config keys
        val pipelineNames = configMap.keys
          .filter(_.contains("."))
          .map(_.split("\\.")(0))
          .toSet
          .toList
        println(s"Extracted pipeline names from config keys: ${pipelineNames.mkString(", ")}")
        pipelineNames
    }
  }
  
  def filterConfigForPipeline(configMap: Map[String, String], pipelineName: String): Map[String, String] = {
    // Filter config entries that start with the pipeline name
    val pipelineConfig = configMap.filter { case (key, _) =>
      key.startsWith(s"$pipelineName.")
    }
    
    // Also include global config entries (those without dots or common global keys)
    val globalConfig = configMap.filter { case (key, _) =>
      !key.contains(".") || isGlobalConfigKey(key)
    }
    
    val combinedConfig = pipelineConfig ++ globalConfig
    println(s"Pipeline '$pipelineName': Found ${combinedConfig.size} relevant config entries")
    combinedConfig
  }
  
  def isGlobalConfigKey(key: String): Boolean = {
    // Define patterns for global configuration keys
    val globalPatterns = Array(
      "pipelines",
      "global.",
      "common.",
      "default."
    )
    globalPatterns.exists(pattern => key.toLowerCase.startsWith(pattern.toLowerCase))
  }
  
  def findMatchingKeys(configMap: Map[String, String], targetKeys: Array[String], pipelineName: String): Map[String, String] = {
    val result = mutable.Map[String, String]()
    
    targetKeys.foreach { targetKey =>
      // Check if this key should always use default values
      if (shouldUseDefaultValue(targetKey)) {
        // First try exact match
        configMap.get(targetKey) match {
          case Some(value) => 
            result(targetKey) = value
            println(s"[$pipelineName] Exact match found: $targetKey = $value")
          case None =>
            // Try pipeline-specific match (pipeline.targetKey)
            val pipelineSpecificKey = s"$pipelineName.$targetKey"
            configMap.get(pipelineSpecificKey) match {
              case Some(value) =>
                result(targetKey) = value
                println(s"[$pipelineName] Pipeline-specific match found: $targetKey -> $pipelineSpecificKey = $value")
              case None =>
                // For these special keys, use default value instead of partial/semantic matching
                val defaultValue = generateDefaultValue(targetKey, pipelineName)
                result(targetKey) = defaultValue
                println(s"[$pipelineName] Default value generated for: $targetKey = $defaultValue")
            }
        }
      } else {
        // Normal matching logic for other keys
        // First try exact match
        configMap.get(targetKey) match {
          case Some(value) => 
            result(targetKey) = value
            println(s"[$pipelineName] Exact match found: $targetKey = $value")
          case None =>
            // Try pipeline-specific match (pipeline.targetKey)
            val pipelineSpecificKey = s"$pipelineName.$targetKey"
            configMap.get(pipelineSpecificKey) match {
              case Some(value) =>
                result(targetKey) = value
                println(s"[$pipelineName] Pipeline-specific match found: $targetKey -> $pipelineSpecificKey = $value")
              case None =>
                // Try partial matching within pipeline scope
                val partialMatch = findPartialMatch(targetKey, configMap, pipelineName)
                partialMatch match {
                  case Some((matchedKey, value)) =>
                    result(targetKey) = value
                    println(s"[$pipelineName] Partial match found: $targetKey -> $matchedKey = $value")
                  case None =>
                    // Try semantic matching
                    val semanticMatch = findSemanticMatch(targetKey, configMap, pipelineName)
                    semanticMatch match {
                      case Some((matchedKey, value)) =>
                        result(targetKey) = value
                        println(s"[$pipelineName] Semantic match found: $targetKey -> $matchedKey = $value")
                      case None =>
                        // Generate default value if no match found
                        val defaultValue = generateDefaultValue(targetKey, pipelineName)
                        result(targetKey) = defaultValue
                        if (defaultValue != "NOT_FOUND") {
                          println(s"[$pipelineName] Default value generated for: $targetKey = $defaultValue")
                        } else {
                          println(s"[$pipelineName] No match found for: $targetKey")
                        }
                    }
                }
            }
        }
      }
    }
    
    result.toMap
  }
  
  def findPartialMatch(targetKey: String, configMap: Map[String, String], pipelineName: String): Option[(String, String)] = {
    val lowerTargetKey = targetKey.toLowerCase
    
    // First, try to find matches within the pipeline scope
    val pipelineKeys = configMap.filter(_._1.startsWith(s"$pipelineName."))
    
    // Look for keys that contain the target key
    pipelineKeys.find { case (configKey, _) =>
      val keyWithoutPipeline = configKey.substring(pipelineName.length + 1).toLowerCase
      keyWithoutPipeline.contains(lowerTargetKey) || lowerTargetKey.contains(keyWithoutPipeline)
    } match {
      case Some((foundKey, value)) => return Some((foundKey, value))
      case None => // Continue searching
    }
    
    // Try matching by the last part of the key within pipeline scope
    val keyParts = lowerTargetKey.split("\\.")
    if (keyParts.nonEmpty) {
      val lastPart = keyParts.last
      pipelineKeys.find { case (configKey, _) =>
        val configKeyParts = configKey.toLowerCase.split("\\.")
        configKeyParts.length > 1 && (
          configKeyParts.last == lastPart || 
          configKey.toLowerCase.contains(lastPart)
        )
      } match {
        case Some((foundKey, value)) => return Some((foundKey, value))
        case None => // Continue searching
      }
    }
    
    // Fallback to global search if no pipeline-specific match found
    configMap.find { case (configKey, _) =>
      val configKeyLower = configKey.toLowerCase
      configKeyLower.contains(lowerTargetKey) || lowerTargetKey.contains(configKeyLower)
    }
  }
  
  def findSemanticMatch(targetKey: String, configMap: Map[String, String], pipelineName: String): Option[(String, String)] = {
    val lowerTargetKey = targetKey.toLowerCase
    
    // Define semantic mappings with pipeline-aware patterns
    val semanticMappings = Map(
      "consumer_offset_start" -> Array("consumer.offset.start", "offset.start", "consumer_offset"),
      "checkpoint_base_path" -> Array("checkpoint_base_path", "checkpoint.base.path", "checkpoint"),
      "print.level" -> Array("print.level", "log.level", "level"),
      "consumer_group" -> Array("consumer.group", "consumer_group", "group"),
      "pipeline" -> Array("pipelines", "pipeline", "id"),
      "transformation.id" -> Array("transformation", "parser.id", "additional.transformation", "staging.id"),
      "source_config.uuid" -> Array("source", "source.id", "source.uuid"),
      "dq" -> Array("validation", "dq", "data.quality"),
      "validation.updflag" -> Array("validation.flag", "validation", "updflag")
    )
    
    // Check semantic mappings with pipeline prefix first
    semanticMappings.get(lowerTargetKey) match {
      case Some(possibleKeys) =>
        // Try pipeline-specific keys first
        possibleKeys.foreach { possibleKey =>
          val pipelineSpecificPattern = s"$pipelineName.$possibleKey"
          configMap.find { case (configKey, _) =>
            configKey.toLowerCase.contains(pipelineSpecificPattern.toLowerCase)
          } match {
            case Some((foundKey, value)) => return Some((foundKey, value))
            case None => // Continue searching
          }
        }
        
        // Try general patterns within pipeline scope
        possibleKeys.foreach { possibleKey =>
          configMap.find { case (configKey, _) =>
            configKey.startsWith(s"$pipelineName.") && 
            configKey.toLowerCase.contains(possibleKey.toLowerCase)
          } match {
            case Some((foundKey, value)) => return Some((foundKey, value))
            case None => // Continue searching
          }
        }
        
        // Fallback to global search
        possibleKeys.foreach { possibleKey =>
          configMap.find { case (configKey, _) =>
            configKey.toLowerCase.contains(possibleKey.toLowerCase)
          } match {
            case Some((foundKey, value)) => return Some((foundKey, value))
            case None => // Continue searching
          }
        }
      case None => // No semantic mapping defined
    }
    
    None
  }
  
  def generateCouchbaseKey(matchedKeys: Map[String, String]): String = {
    val targetConfigUuid = matchedKeys.getOrElse("Target_config.uuid", "")
    val groupsUuid = matchedKeys.getOrElse("groups.uuid", "")
    val sourceConfigUuid = matchedKeys.getOrElse("source_config.uuid", "")
    
    s"${targetConfigUuid}_${groupsUuid}_${sourceConfigUuid}"
  }
  
  def generateJson(matchedKeys: Map[String, String], pipelineName: String): String = {
    val jsonBuilder = new StringBuilder
    jsonBuilder.append("{\n")
    jsonBuilder.append(s"""  "pipeline_name": "$pipelineName",\n""")
    jsonBuilder.append(s"""  "generated_at_epoch": "${getCurrentEpochMillis()}",\n""")
    
    val entries = matchedKeys.toSeq.zipWithIndex
    entries.foreach { case ((key, value), index) =>
      val escapedKey = key.replace("\"", "\\\"")
      val escapedValue = value.replace("\"", "\\\"").replace("\\", "\\\\")
      jsonBuilder.append(s"""  "$escapedKey": "$escapedValue"""")
      if (index < entries.length - 1) {
        jsonBuilder.append(",")
      }
      jsonBuilder.append("\n")
    }
    
    jsonBuilder.append("}")
    jsonBuilder.toString()
  }
  
  def insertToCouchbase(pipelineConfig: PipelineConfig, couchbaseClient: CouchbaseClient): Try[String] = {
    val jsonDocument = generateJson(pipelineConfig.matchedKeys, pipelineConfig.name)
    val couchbaseKey = generateCouchbaseKey(pipelineConfig.matchedKeys)
    
    println(s"\n=== Inserting to Couchbase ===")
    println(s"Pipeline: ${pipelineConfig.name}")
    println(s"Generated Key: $couchbaseKey")
    println(s"Document size: ${jsonDocument.length} characters")
    
    couchbaseClient.insert(couchbaseKey, jsonDocument) match {
      case Success(_) =>
        println(s"✅ Successfully inserted pipeline '${pipelineConfig.name}' to Couchbase")
        Success(couchbaseKey)
      case Failure(exception) =>
        println(s"❌ Failed to insert pipeline '${pipelineConfig.name}' to Couchbase: ${exception.getMessage}")
        Failure(exception)
    }
  }
  
  def processPipelines(configMap: Map[String, String]): List[PipelineConfig] = {
    val pipelines = extractPipelines(configMap)
    
    pipelines.map { pipelineName =>
      println(s"\n=== Processing Pipeline: $pipelineName ===")
      
      // Filter config for this specific pipeline
      val pipelineConfigMap = filterConfigForPipeline(configMap, pipelineName)
      
      // Find matching keys for this pipeline
      val matchedKeys = findMatchingKeys(pipelineConfigMap, jsonKeys, pipelineName)
      
      PipelineConfig(pipelineName, pipelineConfigMap, matchedKeys)
    }
  }
  
  def saveJsonFiles(pipelineConfigs: List[PipelineConfig]): Unit = {
    pipelineConfigs.foreach { pipelineConfig =>
      val jsonOutput = generateJson(pipelineConfig.matchedKeys, pipelineConfig.name)
      val fileName = s"${pipelineConfig.name.toLowerCase}_config_couchbase.json"
      
      Try {
        val writer = new PrintWriter(fileName)
        try {
          writer.write(jsonOutput)
          println(s"JSON output for pipeline '${pipelineConfig.name}' saved to: $fileName")
        } finally {
          writer.close()
        }
      } match {
        case Success(_) => // Success message already printed
        case Failure(exception) => println(s"Error saving file $fileName: ${exception.getMessage}")
      }
    }
  }
  
  def generateCombinedJson(pipelineConfigs: List[PipelineConfig]): String = {
    val jsonBuilder = new StringBuilder
    jsonBuilder.append("{\n")
    jsonBuilder.append(s"""  "total_pipelines": ${pipelineConfigs.length},\n""")
    jsonBuilder.append(s"""  "generated_at_epoch": "${getCurrentEpochMillis()}",\n""")
    jsonBuilder.append(s"""  "couchbase_config": {\n""")
    jsonBuilder.append(s"""    "bucket": "RTCONFIG",\n""")
    jsonBuilder.append(s"""    "scope": "CITIDIRECT",\n""")
    jsonBuilder.append(s"""    "collection": "PIPELINES"\n""")
    jsonBuilder.append(s"""  },\n""")
    jsonBuilder.append("""  "pipelines": [""").append("\n")
    
    pipelineConfigs.zipWithIndex.foreach { case (pipelineConfig, index) =>
      val pipelineJson = generateJson(pipelineConfig.matchedKeys, pipelineConfig.name)
      val couchbaseKey = generateCouchbaseKey(pipelineConfig.matchedKeys)
      
      jsonBuilder.append("    {\n")
      jsonBuilder.append(s"""      "couchbase_key": "$couchbaseKey",\n""")
      jsonBuilder.append(s"""      "document": """).append(pipelineJson.replace("\n", "\\n").replace("\"", "\\\"")).append("\n")
      jsonBuilder.append("    }")
      
      if (index < pipelineConfigs.length - 1) {
        jsonBuilder.append(",")
      }
      jsonBuilder.append("\n")
    }
    
    jsonBuilder.append("  ]\n")
    jsonBuilder.append("}")
    jsonBuilder.toString()
  }
  
  def printSummary(pipelineConfigs: List[PipelineConfig], couchbaseResults: List[Try[String]]): Unit = {
    println(s"\n=== OVERALL SUMMARY ===")
    println(s"Total pipelines processed: ${pipelineConfigs.length}")
    println(s"Target keys searched per pipeline: ${jsonKeys.length}")
    println(s"Current epoch time: ${getCurrentEpochMillis()}")
    
    val successfulInserts = couchbaseResults.count(_.isSuccess)
    val failedInserts = couchbaseResults.count(_.isFailure)
    
    println(s"\n=== Couchbase Insert Summary ===")
    println(s"Successful inserts: $successfulInserts")
    println(s"Failed inserts: $failedInserts")
    println(s"Success rate: ${if (pipelineConfigs.nonEmpty) (successfulInserts.toDouble / pipelineConfigs.length * 100).round else 0}%")
    
    pipelineConfigs.zip(couchbaseResults).foreach { case (pipelineConfig, result) =>
      val foundCount = pipelineConfig.matchedKeys.count(_._2 != "NOT_FOUND")
      val notFoundCount = pipelineConfig.matchedKeys.count(_._2 == "NOT_FOUND")
      val couchbaseKey = generateCouchbaseKey(pipelineConfig.matchedKeys)
      
      // Count default values applied
      val defaultCount = pipelineConfig.matchedKeys.count { case (key, value) =>
        value != "NOT_FOUND" && (
          key == "LstUpdDt" || key == "CrtDt" || key == "CrtUsr" || key == "UpdUsr" || key == "Target_config.uuid"
        ) && (
          value == "Admin" || value.matches("\\d+") || value.contains("+Couchbase+")
        )
      }
      
      println(s"\nPipeline: ${pipelineConfig.name}")
      println(s"  - Keys found: $foundCount/${jsonKeys.length}")
      println(s"  - Keys with defaults: $defaultCount")
      println(s"  - Keys not found: $notFoundCount")
      println(s"  - Success rate: ${(foundCount.toDouble / jsonKeys.length * 100).round}%")
      println(s"  - Couchbase key: $couchbaseKey")
      println(s"  - Couchbase insert: ${if (result.isSuccess) "✅ SUCCESS" else "❌ FAILED"}")
      
      if (notFoundCount > 0) {
        println(s"  - Missing keys: ${pipelineConfig.matchedKeys.filter(_._2 == "NOT_FOUND").keys.mkString(", ")}")
      }
      
      // Show default values applied
      val defaultValues = pipelineConfig.matchedKeys.filter { case (key, value) =>
        (key == "LstUpdDt" || key == "CrtDt") && value.matches("\\d+") ||
        (key == "CrtUsr" || key == "UpdUsr") && value == "Admin" ||
        key == "Target_config.uuid" && value.contains("+Couchbase+")
      }
      
      if (defaultValues.nonEmpty) {
        println(s"  - Default values applied:")
        defaultValues.foreach { case (key, value) =>
          println(s"    * $key = $value")
        }
      }
    }
  }
  
  def main(args: Array[String]): Unit = {
    val configFilePath = if (args.nonEmpty) args(0) else "/home/ubuntu/upload/configload.txt"
    
    // Couchbase configuration (can be passed as command line arguments or environment variables)
    val couchbaseConfig = CouchbaseConfig(
      connectionString = sys.env.getOrElse("COUCHBASE_CONNECTION_STRING", "couchbase://localhost"),
      username = sys.env.getOrElse("COUCHBASE_USERNAME", "Administrator"),
      password = sys.env.getOrElse("COUCHBASE_PASSWORD", "password")
    )
    
    println("=== Enhanced Config Parser with Couchbase Integration Started ===")
    println(s"Parsing config file: $configFilePath")
    println(s"Looking for ${jsonKeys.length} keys per pipeline...")
    println(s"Current epoch time: ${getCurrentEpochMillis()}")
    println(s"Couchbase target: ${couchbaseConfig.bucketName}.${couchbaseConfig.scopeName}.${couchbaseConfig.collectionName}")
    println()
    
    // Parse the config file
    val configMap = parseConfigFile(configFilePath)
    
    if (configMap.nonEmpty) {
      println(s"Loaded ${configMap.size} configuration entries")
      
      // Process all pipelines
      val pipelineConfigs = processPipelines(configMap)
      
      if (pipelineConfigs.nonEmpty) {
        println(s"\n=== Results for ${pipelineConfigs.length} pipelines ===")
        
        // Save individual JSON files for each pipeline
        saveJsonFiles(pipelineConfigs)
        
        // Initialize Couchbase client
        val couchbaseClient: CouchbaseClient = new MockCouchbaseClient(couchbaseConfig)
        // For actual Couchbase integration, use:
        // val couchbaseClient: CouchbaseClient = new ActualCouchbaseClient(couchbaseConfig)
        
        try {
          // Insert each pipeline configuration to Couchbase
          val couchbaseResults = pipelineConfigs.map { pipelineConfig =>
            insertToCouchbase(pipelineConfig, couchbaseClient)
          }
          
          // Generate and save combined JSON with Couchbase metadata
          val combinedJson = generateCombinedJson(pipelineConfigs)
          Try {
            val writer = new PrintWriter("all_pipelines_config_couchbase.json")
            try {
              writer.write(combinedJson)
              println(s"\nCombined JSON output with Couchbase metadata saved to: all_pipelines_config_couchbase.json")
            } finally {
              writer.close()
            }
          } match {
            case Success(_) => // Success message already printed
            case Failure(exception) => println(s"Error saving combined file: ${exception.getMessage}")
          }
          
          // Print summary
          printSummary(pipelineConfigs, couchbaseResults)
          
        } finally {
          // Close Couchbase client
          couchbaseClient.close()
        }
        
      } else {
        println("No pipelines found in configuration")
      }
      
    } else {
      println("Failed to parse config file or file is empty")
    }
    
    println("\n=== Enhanced Config Parser with Couchbase Integration Completed ===")
  }
}

